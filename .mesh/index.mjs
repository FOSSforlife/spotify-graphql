import { AggregateError } from '@graphql-tools/utils';
import { parse } from 'graphql';
import { getMesh } from '@graphql-mesh/runtime';
import { MeshStore, FsStoreStorageAdapter } from '@graphql-mesh/store';
import { join, relative, isAbsolute, dirname } from 'path';
import { fileURLToPath } from 'url';
import ExternalModule_0 from '@graphql-mesh/cache-inmemory-lru';
import ExternalModule_1 from '@graphql-mesh/json-schema';
import ExternalModule_2 from '@graphql-mesh/transform-filter-schema';
import ExternalModule_3 from '@graphql-mesh/merger-bare';
import ExternalModule_4 from './sources/Spotify/jsonSchema.json.cjs';
const importedModules = {
    // @ts-ignore
    ["@graphql-mesh/cache-inmemory-lru"]: ExternalModule_0,
    // @ts-ignore
    ["@graphql-mesh/json-schema"]: ExternalModule_1,
    // @ts-ignore
    ["@graphql-mesh/transform-filter-schema"]: ExternalModule_2,
    // @ts-ignore
    ["@graphql-mesh/merger-bare"]: ExternalModule_3,
    // @ts-ignore
    [".mesh/sources/Spotify/jsonSchema.json.cjs"]: ExternalModule_4
};
const baseDir = join(dirname(fileURLToPath(import.meta.url)), '..');
const importFn = (moduleId) => {
    const relativeModuleId = (isAbsolute(moduleId) ? relative(baseDir, moduleId) : moduleId).split('\\').join('/');
    if (!(relativeModuleId in importedModules)) {
        throw new Error(`Cannot find module '${relativeModuleId}'.`);
    }
    return Promise.resolve(importedModules[relativeModuleId]);
};
const rootStore = new MeshStore('.mesh', new FsStoreStorageAdapter({
    cwd: baseDir,
    importFn,
}), {
    readonly: true,
    validate: false
});
import MeshCache from '@graphql-mesh/cache-inmemory-lru';
import { PubSub } from '@graphql-mesh/utils';
import { DefaultLogger } from '@graphql-mesh/utils';
import JsonSchemaHandler from '@graphql-mesh/json-schema';
import FilterSchemaTransform from '@graphql-mesh/transform-filter-schema';
import BareMerger from '@graphql-mesh/merger-bare';
import { resolveAdditionalResolvers } from '@graphql-mesh/utils';
export const rawConfig = { "sources": [{ "name": "Spotify", "handler": { "JsonSchema": { "baseUrl": "https://api.spotify.com/v1/", "operationHeaders": { "Authorization": "Bearer {env.TOKEN}" }, "operations": [{ "type": "Query", "field": "album", "description": "Get an Album: Get Spotify catalog information for a single album.", "path": "/albums/{args.id}", "requestSchema": "./json-schemas/base.json#/definitions/AlbumInput", "argTypeMap": { "id": "String" }, "responseSchema": "./json-schemas/base.json#/definitions/AlbumObject" }, { "type": "Query", "field": "albums", "description": "Get Multiple Albums: Get Spotify catalog information for multiple albums identified by their Spotify IDs.", "path": "/albums", "requestSchema": "./json-schemas/base.json#/definitions/AlbumsInput", "responseSchema": "./json-schemas/base.json#/definitions/AlbumsOutput" }, { "type": "Query", "field": "albumTracks", "description": "Get an Album: Get Spotify catalog information for a single album.", "path": "/albums/{args.id}/tracks", "requestSchema": "./json-schemas/base.json#/definitions/AlbumTracksInput", "argTypeMap": { "id": "String" }, "responseSchema": "./json-schemas/base.json#/definitions/AlbumTracksOutput" }, { "type": "Query", "field": "artist", "description": "Get an Artist: Get Spotify catalog information for a single artist identified by their unique Spotify ID.", "path": "/artists/{args.id}", "requestSchema": "./json-schemas/base.json#/definitions/ArtistInput", "argTypeMap": { "id": "String" }, "responseSchema": "./json-schemas/base.json#/definitions/ArtistObject" }, { "type": "Query", "field": "artistAlbums", "description": "Get an Artist's Albums: Get Spotify catalog information about an artist’s albums.", "path": "/artists/{args.id}/albums", "requestSchema": "./json-schemas/base.json#/definitions/ArtistAlbumsInput", "argTypeMap": { "id": "String" }, "responseSchema": "./json-schemas/base.json#/definitions/ArtistAlbumsOutput" }, { "type": "Query", "field": "artistRelatedArtists", "description": "Get an Artist's Related Artists: Get Spotify catalog information about artists similar to a given artist. Similarity is based on analysis of the Spotify community’s listening history.", "path": "/artists/{args.id}/related-artists", "responseSchema": "./json-schemas/base.json#/definitions/ArtistRelatedArtistsOutput", "argTypeMap": { "id": "String" } }, { "type": "Query", "field": "artists", "description": "Get Multiple Artists: Get Spotify catalog information for several artists based on their Spotify IDs.", "path": "/artists", "requestSchema": "./json-schemas/base.json#/definitions/ArtistsInput", "responseSchema": "./json-schemas/base.json#/definitions/ArtistsOutput" }, { "type": "Query", "field": "artistTopTracks", "description": "Get an Artist's Top Tracks: Get Spotify catalog information about an artist’s top tracks by country.", "path": "/artists/{args.id}/top-tracks?market={args.market}", "requestSchema": "./json-schemas/base.json#/definitions/ArtistTopTracksInput", "argTypeMap": { "id": "String" }, "responseSchema": "./json-schemas/base.json#/definitions/ArtistTopTracksOutput" }, { "type": "Query", "field": "browseCategories", "description": "Get All Categories: Get a list of categories used to tag items in Spotify (on, for example, the Spotify player’s “Browse” tab).", "path": "/browse/categories", "requestSchema": "./json-schemas/base.json#/definitions/BrowseCategoriesInput", "responseSchema": "./json-schemas/base.json#/definitions/BrowseCategoriesOutput" }, { "type": "Query", "field": "browseCategory", "description": "Get a Category: Get a single category used to tag items in Spotify (on, for example, the Spotify player’s “Browse” tab).", "path": "/browse/categories/{args.category_id}", "requestSchema": "./json-schemas/base.json#/definitions/BrowseCategoriesInput", "argTypeMap": { "category_id": "String" }, "responseSchema": "./json-schemas/base.json#/definitions/CategoryObject" }, { "type": "Query", "field": "browseCategoryPlaylists", "description": "Get a Category's Playlists: Get a list of Spotify playlists tagged with a particular category.", "path": "/browse/categories/{args.category_id}/playlists", "requestSchema": "./json-schemas/base.json#/definitions/BrowseCategoryPlaylistsInput", "argTypeMap": { "category_id": "String" }, "responseSchema": "./json-schemas/base.json#/definitions/BrowseCategoryPlaylistsOutput" }, { "type": "Query", "field": "browseFeaturedPlaylists", "description": "Get All New Releases: Get a list of new album releases featured in Spotify (shown, for example, on a Spotify player’s “Browse” tab).", "path": "/browse/featured-playlists", "requestSchema": "./json-schemas/base.json#/definitions/BrowseFeaturedPlaylistsInput", "responseSchema": "./json-schemas/base.json#/definitions/BrowseFeaturedPlaylistsOutput" }, { "type": "Query", "field": "browseGenresSeed", "description": "Get Recommendation Genres: Retrieve a list of available genres seed parameter values for recommendations.", "path": "/recommendations/available-genre-seeds", "responseSchema": "./json-schemas/base.json#/definitions/BrowseGenresSeedOutput" }, { "type": "Query", "field": "browseNewReleases", "description": "Get All New Releases: Get a list of new album releases featured in Spotify (shown, for example, on a Spotify player’s “Browse” tab).", "path": "/browse/new-releases", "requestSchema": "./json-schemas/base.json#/definitions/BrowseNewReleasesInput", "responseSchema": "./json-schemas/base.json#/definitions/BrowseNewReleasesOutput" }, { "type": "Query", "field": "episode", "description": "Get an Episode: Get Spotify catalog information for a single episode identified by its unique Spotify ID.", "path": "/episodes/{args.id}", "requestSchema": "./json-schemas/base.json#/definitions/EpisodeInput", "argTypeMap": { "id": "String" }, "responseSchema": "./json-schemas/base.json#/definitions/EpisodeObject" }, { "type": "Query", "field": "episodes", "description": "Get Multiple Episodes: Get Spotify catalog information for several episodes based on their Spotify IDs.", "path": "/episodes", "requestSchema": "./json-schemas/base.json#/definitions/EpisodesInput", "responseSchema": "./json-schemas/base.json#/definitions/EpisodesOutput" }, { "type": "Query", "field": "checkUsersFollowPlaylist", "description": "Check if Users Follow a Playlist: Check to see if one or more Spotify users are following a specified playlist.", "path": "/playlists/{args.playlist_id}/followers/contains?ids={args.ids}", "responseTypeName": "Void", "argTypeMap": { "ids": "String" } }, { "type": "Mutation", "field": "followArtists", "method": "PUT", "path": "/me/following?type=artist&ids={args.ids}", "responseTypeName": "Void", "argTypeMap": { "ids": "String" } }, { "type": "Mutation", "field": "followPlaylist", "method": "PUT", "description": "Follow a Playlist: Add the current user as a follower of a playlist.", "path": "/playlists/{args.playlist_id}/follower", "requestSchema": "./json-schemas/base.json#/definitions/FollowPlaylistInput", "responseTypeName": "Void" }, { "type": "Mutation", "field": "followUsers", "method": "PUT", "path": "/me/following?type=user&ids={args.ids}", "responseTypeName": "Void", "argTypeMap": { "ids": "String" } }, { "type": "Query", "field": "meFollowingArtists", "description": "Get User's Followed Artists: Get the current user’s followed artists.", "path": "/me/following?type=artist", "requestSchema": "./json-schemas/base.json#/definitions/MeFollowingArtistsInput", "responseSchema": "./json-schemas/base.json#/definitions/MeFollowingArtistsOutput" }, { "type": "Query", "field": "meIsFollowing", "path": "/me/following/contains?type={args.type}&ids={args.ids}", "argTypeMap": { "ids": "String", "type": "String" }, "responseSchema": "./json-schemas/base.json#/definitions/ArrayOfBooleans" }, { "type": "Mutation", "field": "unfollowArtists", "method": "DELETE", "path": "/me/following?type=artist&ids={args.ids}", "responseTypeName": "Void", "argTypeMap": { "ids": "String" } }, { "type": "Mutation", "field": "unfollowPlaylist", "method": "DELETE", "description": "Unfollow Playlist: Remove the current user as a follower of a playlist.", "path": "/playlists/{args.playlist_id}/follower", "responseTypeName": "Void" }, { "type": "Mutation", "field": "unfollowUsers", "method": "DELETE", "path": "/me/following?type=user&ids={args.ids}", "responseTypeName": "Void", "argTypeMap": { "ids": "String" } }, { "type": "Query", "field": "meAlbums", "description": "Get User's Saved Albums: Get a list of the albums saved in the current Spotify user’s ‘Your Music’ library.", "path": "/me/albums", "requestSchema": "./json-schemas/base.json#/definitions/MeAlbumsInput", "responseSchema": "./json-schemas/base.json#/definitions/MeAlbumsOutput" }, { "type": "Query", "field": "meAlbumsContains", "description": "Check User's Saved Albums: Check if one or more albums is already saved in the current Spotify user’s ‘Your Music’ library.", "path": "/me/albums/contains?ids={args.ids}", "requestSchema": "./json-schemas/base.json#/definitions/MeAlbumsContainsInput", "responseSchema": "./json-schemas/base.json#/definitions/ArrayOfBooleans" }, { "type": "Mutation", "field": "meRemoveAlbums", "method": "DELETE", "description": "Remove Albums for Current User: Remove one or more albums from the current user’s ‘Your Music’ library.", "path": "/me/albums", "requestSchema": "./json-schemas/base.json#/definitions/MeRemoveAlbumsInput", "responseTypeName": "Void" }, { "type": "Mutation", "field": "meRemoveShows", "method": "DELETE", "description": "Remove Shows for Current User: Remove one or more Shows from the current user’s ‘Your Music’ library.", "path": "/me/shows", "requestSchema": "./json-schemas/base.json#/definitions/MeRemoveShowsInput", "responseTypeName": "Void" }, { "type": "Mutation", "field": "meRemoveTracks", "method": "DELETE", "description": "Remove Tracks for Current User: Remove one or more Tracks from the current user’s ‘Your Music’ library.", "path": "/me/tracks", "requestSchema": "./json-schemas/base.json#/definitions/MeRemoveTracksInput", "responseTypeName": "Void" }, { "type": "Mutation", "field": "meSaveAlbums", "method": "PUT", "description": "Save Albums for Current User: Save one or more albums to the current user’s ‘Your Music’ library.", "path": "/me/albums", "requestSchema": "./json-schemas/base.json#/definitions/MeSaveAlbumsInput", "responseTypeName": "Void" }, { "type": "Mutation", "field": "meSaveShows", "method": "PUT", "description": "Save Shows for Current User: Save one or more shows to the current user’s ‘Your Music’ library.", "path": "/me/shows", "requestSchema": "./json-schemas/base.json#/definitions/MeSaveShowsInput", "responseTypeName": "Void" }, { "type": "Mutation", "field": "meSaveTracks", "method": "PUT", "description": "Save Tracks for Current User: Save one or more tracks to the current user’s ‘Your Music’ library.", "path": "/me/tracks", "requestSchema": "./json-schemas/base.json#/definitions/MeSaveTracksInput", "responseTypeName": "Void" }, { "type": "Query", "field": "meShows", "description": "Get User's Saved Shows: Get a list of shows saved in the current Spotify user’s library. Optional parameters can be used to limit the number of shows returned.", "path": "/me/shows", "requestSchema": "./json-schemas/base.json#/definitions/MeShowsInput", "responseSchema": "./json-schemas/base.json#/definitions/MeShowsOutput" }, { "type": "Query", "field": "meShowsContains", "description": "Check User's Saved Shows: Check if one or more shows is already saved in the current Spotify user’s ‘Your Music’ library.", "path": "/me/shows/contains?ids={args.ids}", "requestSchema": "./json-schemas/base.json#/definitions/MeShowsContainsInput", "responseSchema": "./json-schemas/base.json#/definitions/ArrayOfBooleans" }, { "type": "Query", "field": "meTracks", "description": "Get User's Saved Tracks: Get a list of the songs saved in the current Spotify user’s ‘Your Music’ library.", "path": "/me/tracks", "requestSchema": "./json-schemas/base.json#/definitions/MeTracksInput", "responseSchema": "./json-schemas/base.json#/definitions/MeTracksOutput" }, { "type": "Query", "field": "meTracksContains", "description": "Check User's Saved Tracks: Check if one or more tracks is already saved in the current Spotify user’s ‘Your Music’ library.", "path": "/me/tracks/contains?ids={args.ids}", "requestSchema": "./json-schemas/base.json#/definitions/MeTracksContainsInput", "responseSchema": "./json-schemas/base.json#/definitions/ArrayOfBooleans" }, { "type": "Query", "field": "meTopArtists", "description": "Get Current User top artists", "path": "/me/top/artists", "requestSchema": "./json-schemas/base.json#/definitions/MeTopArtistsInput", "responseSchema": "./json-schemas/base.json#/definitions/MeTopArtistsOutput" }, { "type": "Query", "field": "meTopTracks", "description": "Get Current User top tracks", "path": "/me/top/tracks", "requestSchema": "./json-schemas/base.json#/definitions/MeTopTracksInput", "responseSchema": "./json-schemas/base.json#/definitions/MeTopTracksOutput" }, { "type": "Query", "field": "player", "description": "Get Information About The User's Current Playback: Get information about the user’s current playback state, including track or episode, progress, and active device.", "path": "/me/player", "requestSchema": "./json-schemas/base.json#/definitions/PlayerInput", "responseSchema": "./json-schemas/base.json#/definitions/CurrentlyPlayingContextObject" }, { "type": "Query", "field": "playerCurrentlyPlaying", "description": "Get the User's Currently Playing Track: Get the object currently being played on the user’s Spotify account.", "path": "/me/player/currently-playing", "requestSchema": "./json-schemas/base.json#/definitions/PlayerCurrentlyPlayingInput", "responseSchema": "./json-schemas/base.json#/definitions/CurrentlyPlayingContextObject" }, { "type": "Query", "field": "playerDevices", "description": "Get a User's Available Devices: Get information about a user’s available devices.", "path": "/me/player/devices", "responseSchema": "./json-schemas/base.json#/definitions/DevicesObject" }, { "type": "Mutation", "field": "playerPause", "method": "PUT", "description": "Skip User’s Playback To Next Track: Skips to next track in the user’s queue.", "path": "/me/player/next", "responseTypeName": "Void" }, { "type": "Mutation", "field": "playerPause", "method": "PUT", "description": "Skip User’s Playback To Next Track: Skips to next track in the user’s queue.", "path": "/me/player/next?device_id={args.device_id}", "responseTypeName": "Void" }, { "type": "Mutation", "field": "playerPause", "method": "PUT", "description": "Pause a User's Playback: Pause playback on the user’s account.", "path": "/me/player/pause", "responseTypeName": "Void" }, { "type": "Mutation", "field": "playerPauseForDevice", "method": "PUT", "description": "Pause a User's Playback: Pause playback on the user’s account.", "path": "/me/player/pause?device_id={args.device_id}", "responseTypeName": "Void" }, { "type": "Mutation", "field": "playerPlay", "method": "PUT", "description": "Start/Resume a User's Playback: Start a new context or resume current playback on the user’s active device.", "path": "/me/player/play", "requestSchema": "./json-schemas/base.json#/definitions/PlayerPlayInput", "responseTypeName": "Void" }, { "type": "Mutation", "field": "playerPlayForDevice", "method": "PUT", "description": "Start/Resume a User's Playback: Start a new context or resume current playback on the user’s active device.", "path": "/me/player/play?device_id={args.device_id}", "requestSchema": "./json-schemas/base.json#/definitions/PlayerPlayInput", "responseTypeName": "Void" }, { "type": "Mutation", "field": "playerPrevious", "method": "PUT", "description": "Skip User’s Playback To Previous Track: Skips to previous track in the user’s queue.", "path": "/me/player/previous", "responseTypeName": "Void" }, { "type": "Mutation", "field": "playerPreviousForDevice", "method": "PUT", "description": "Skip User’s Playback To Previous Track: Skips to previous track in the user’s queue.", "path": "/me/player/previous?device_id={args.device_id}", "responseTypeName": "Void" }, { "type": "Mutation", "field": "playerQueue", "method": "PUT", "description": "Add an item to queue: Add an item to the end of the user’s current playback queue.", "path": "/me/player/queue?uri={args.uri}", "responseTypeName": "Void" }, { "type": "Mutation", "field": "playerQueueForDevice", "method": "PUT", "description": "Add an item to queue: Add an item to the end of the user’s current playback queue.", "path": "/me/player/queue?device_id={args.device_id}&uri={args.uri}", "responseTypeName": "Void" }, { "type": "Query", "field": "playerRecentlyPlayed", "description": "Get Current User's Recently Played Tracks: Get tracks from the current user’s recently played tracks. Note: Currently doesn’t support podcast episodes.", "path": "/me/player/recently-played", "requestSchema": "./json-schemas/base.json#/definitions/PlayerRecentlyPlayedInput", "responseSchema": "./json-schemas/base.json#/definitions/PlayerRecentlyPlayedOutput" }, { "type": "Mutation", "field": "playerRepeat", "method": "PUT", "description": "Set Repeat Mode On User’s Playback: Set the repeat mode for the user’s playback. Options are repeat-track, repeat-context, and off.", "path": "/me/player/repeat?state={args.state}", "responseTypeName": "Void" }, { "type": "Mutation", "field": "playerRepeatForDevice", "method": "PUT", "description": "Set Repeat Mode On User’s Playback: Set the repeat mode for the user’s playback. Options are repeat-track, repeat-context, and off.", "path": "/me/player/repeat?device_id={args.device_id}&state={args.state}", "responseTypeName": "Void" }, { "type": "Mutation", "field": "playerSeek", "method": "PUT", "description": "Seek To Position In Currently Playing Track: Seeks to the given position in the user’s currently playing track.", "path": "/me/player/seek?position_ms={args.position_ms}", "responseTypeName": "Void", "argTypeMap": { "position_ms": "Int" } }, { "type": "Mutation", "field": "playerSeekForDevice", "method": "PUT", "description": "Seek To Position In Currently Playing Track: Seeks to the given position in the user’s currently playing track.", "path": "/me/player/seek?device_id={args.device_id}&position_ms={args.position_ms}", "responseTypeName": "Void", "argTypeMap": { "position_ms": "Int" } }, { "type": "Mutation", "field": "playerShuffle", "method": "PUT", "description": "Toggle Shuffle For User’s Playback: Toggle shuffle on or off for user’s playback.", "path": "/me/player/shuffle?state={args.state}", "responseTypeName": "Void", "argTypeMap": { "state": "Boolean" } }, { "type": "Mutation", "field": "playerShuffleForDevice", "method": "PUT", "description": "Toggle Shuffle For User’s Playback: Toggle shuffle on or off for user’s playback.", "path": "/me/player/shuffle?device_id={args.device_id}&state={args.state}", "responseTypeName": "Void", "argTypeMap": { "state": "Boolean" } }, { "type": "Mutation", "field": "playerTransfer", "method": "PUT", "description": "Get a User's Available Devices: Get information about a user’s available devices.", "path": "/me/player/devices", "requestSchema": "./json-schemas/base.json#/definitions/PlayerTransferInput", "responseTypeName": "Void" }, { "type": "Mutation", "field": "playerVolume", "method": "PUT", "description": "Set Volume For User's Playback: Set the volume for the user’s current playback device.", "path": "/me/player/volume?volume_percent={args.state}", "responseTypeName": "Void", "argTypeMap": { "volume_percent": "Int" } }, { "type": "Mutation", "field": "playerVolumeForDevice", "method": "PUT", "description": "Set Volume For User's Playback: Set the volume for the user’s current playback device.", "path": "/me/player/volume?device_id={args.device_id}&volume_percent={args.state}", "responseTypeName": "Void", "argTypeMap": { "volume_percent": "Int" } }, { "type": "Mutation", "field": "createPlaylist", "description": "Create a Playlist: Create a playlist for a Spotify user. (The playlist will be empty until you add tracks.)", "path": "/users/{args.user_id}/playlists", "requestSchema": "./json-schemas/base.json#/definitions/UserPlaylistsInput", "argTypeMap": { "user_id": "String" }, "responseSchema": "./json-schemas/base.json#/definitions/PlaylistObject" }, { "type": "Query", "field": "mePlaylists", "description": "Get a List of Current User's Playlists: Get a list of the playlists owned or followed by the current Spotify user.", "path": "/me/playlists", "requestSchema": "./json-schemas/base.json#/definitions/MePlaylistsInput", "responseSchema": "./json-schemas/base.json#/definitions/MePlaylistsOutput" }, { "type": "Query", "field": "playlist", "description": "Get a Playlist: Get a playlist owned by a Spotify user.", "path": "/playlists/{args.id}", "requestSchema": "./json-schemas/base.json#/definitions/PlaylistInput", "argTypeMap": { "id": "String" }, "responseSchema": "./json-schemas/base.json#/definitions/PlaylistObject" }, { "type": "Mutation", "field": "playlistAddItem", "description": "Add Items to a Playlist: Add one or more items to a user’s playlist.", "path": "/playlists/{args.id}/tracks", "requestSchema": "./json-schemas/base.json#/definitions/PlaylistAddItemInput", "argTypeMap": { "id": "String" }, "responseSchema": "./json-schemas/base.json#/definitions/PlaylistAddItemOutput" }, { "type": "Query", "field": "playlistCoverImages", "description": "Get a Playlist Cover Image: Get the current image associated with a specific playlist.", "path": "/playlists/{args.id}/images", "responseSchema": "./json-schemas/base.json#/definitions/ArrayOfImageObjects", "argTypeMap": { "id": "String" } }, { "type": "Mutation", "field": "playlistRemoveItems", "method": "DELETE", "description": "Remove Items from a Playlist: Remove one or more items from a user’s playlist.", "path": "/playlists/{args.id}/tracks", "requestSchema": "./json-schemas/base.json#/definitions/PlaylistRemoveItemsInput", "argTypeMap": { "id": "String" }, "responseSchema": "./json-schemas/base.json#/definitions/PlaylistRemoveItemsOutput" }, { "type": "Mutation", "field": "playlistReorderOrReplaceItems", "method": "PUT", "description": "Reorder or Replace a Playlist's Items", "path": "/playlists/{args.id}/tracks", "requestSchema": "./json-schemas/base.json#/definitions/PlaylistAddItemInput", "responseSchema": "./json-schemas/base.json#/definitions/PlaylistAddItemOutput", "argTypeMap": { "id": "String" } }, { "type": "Query", "field": "playlistTracks", "description": "Get a Playlist: Get a playlist owned by a Spotify user.", "path": "/playlists/{args.id}/tracks", "requestSchema": "./json-schemas/base.json#/definitions/PlaylistTracksInput", "responseSchema": "./json-schemas/base.json#/definitions/PlaylistTracksOutput", "argTypeMap": { "id": "String" } }, { "type": "Mutation", "field": "updatePlaylist", "method": "PUT", "description": "Change a Playlist's Details: Change a playlist’s name and public/private state. (The user must, of course, own the playlist.)", "path": "/playlists/{args.id}", "requestSchema": "./json-schemas/base.json#/definitions/UpdatePlaylistInput", "argTypeMap": { "id": "String" }, "responseSchema": "./json-schemas/base.json#/definitions/PlaylistObject" }, { "type": "Query", "field": "userPlaylists", "description": "Get a List of a User's Playlists: Get a list of the playlists owned or followed by a Spotify user.", "path": "/users/{args.user_id}/playlists", "requestSchema": "./json-schemas/base.json#/definitions/UserPlaylistsInput", "responseSchema": "./json-schemas/base.json#/definitions/UserPlaylistsOutput", "argTypeMap": { "user_id": "String" } }, { "type": "Query", "field": "search", "description": "Search for an Item: Get Spotify Catalog information about albums, artists, playlists, tracks, shows or episodes that match a keyword string.", "path": "/search", "requestSchema": "./json-schemas/base.json#/definitions/Search", "responseSchema": "./json-schemas/base.json#/definitions/SearchResults" }, { "type": "Query", "field": "show", "description": "Get a Show: Get Spotify catalog information for a single show identified by its unique Spotify ID.", "path": "/shows/{args.id}", "requestSchema": "./json-schemas/base.json#/definitions/ShowInput", "argTypeMap": { "id": "String" }, "responseSchema": "./json-schemas/base.json#/definitions/ShowObject" }, { "type": "Query", "field": "showEpisodes", "description": "Get a Show's Episodes: Get Spotify catalog information about an show’s episodes. Optional parameters can be used to limit the number of episodes returned.", "path": "/shows/{args.id}/episodes", "requestSchema": "./json-schemas/base.json#/definitions/ShowEpisodesInput", "responseSchema": "./json-schemas/base.json#/definitions/ShowEpisodesOutput", "argTypeMap": { "id": "String" } }, { "type": "Query", "field": "shows", "description": "Get Multiple Shows: Get Spotify catalog information for several shows based on their Spotify IDs.", "path": "/shows", "requestSchema": "./json-schemas/base.json#/definitions/ShowsInput", "responseSchema": "./json-schemas/base.json#/definitions/ShowsOutput" }, { "type": "Query", "field": "track", "description": "Get a Track: Get Spotify catalog information for a single track identified by its unique Spotify ID.", "path": "/tracks/{args.id}", "requestSchema": "./json-schemas/base.json#/definitions/TrackInput", "argTypeMap": { "id": "String" }, "responseSchema": "./json-schemas/base.json#/definitions/TrackObject" }, { "type": "Query", "field": "trackAudioFeatures", "description": "Get Audio Features for a Track: Get audio feature information for a single track identified by its unique Spotify ID.", "path": "/audio-features/{args.id}", "requestSchema": "./json-schemas/base.json#/definitions/TrackAudioFeaturesInput", "argTypeMap": { "id": "String" }, "responseSchema": "./json-schemas/base.json#/definitions/AudioFeaturesObject" }, { "type": "Query", "field": "tracks", "description": "Get Several Tracks: Get Spotify catalog information for multiple tracks based on their Spotify IDs.", "path": "/tracks", "requestSchema": "./json-schemas/base.json#/definitions/TracksInput", "responseSchema": "./json-schemas/base.json#/definitions/TracksOutput" }, { "type": "Query", "field": "tracksAudioFeatures", "description": "Get Audio Features for Several Tracks: Get audio features for multiple tracks based on their Spotify IDs.", "path": "/audio-features", "requestSchema": "./json-schemas/base.json#/definitions/TracksAudioFeaturesInput", "responseSchema": "./json-schemas/base.json#/definitions/TracksAudioFeaturesOutput" }, { "type": "Query", "field": "me", "description": "Get Current User's Profile: Get detailed profile information about the current user (including the current user’s username).", "path": "/me", "responseSchema": "./json-schemas/base.json#/definitions/PrivateUserObject" }, { "type": "Query", "field": "user", "description": "Get a User's Profile: Get public profile information about a Spotify user.", "path": "/users/{args.id}", "argTypeMap": { "id": "String" }, "responseSchema": "./json-schemas/base.json#/definitions/PublicUserObject" }] } } }], "additionalTypeDefs": ["\n        extend type PrivateUserObject {\n          playlists: BrowseFeaturedPlaylistsPlaylists!\n          player: CurrentlyPlayingContextObject!\n          albums: MeAlbumsOutput!\n          tracks: MeTracksOutput!\n          topTracks: MeTopTracksOutput!\n          topArtists: MeTopArtistsOutput!\n          followingArtists: MeFollowingArtistsOutput!\n          shows: MeShowsOutput!\n          albumsContains(ids: String!): [Boolean!]!\n          showsContains(ids: String!): [Boolean!]!\n          tracksContains(ids: String!): [Boolean!]!\n        }\n        extend type AlbumObject {\n          tracksFull: AlbumTracksOutput!\n        }\n        extend type ArtistObject {\n          albums: ArtistAlbumsOutput!\n          topTracks(market: String!): ArtistTopTracksOutput!\n          relatedArtists: ArtistRelatedArtistsOutput!\n        }\n        extend type CurrentlyPlayingContextObject {\n          recentlyPlayed: PlayerRecentlyPlayedOutput!\n          devices: DevicesObject!\n        }\n        extend type ShowObject {\n          episodesFull: ShowEpisodesOutput!\n        }\n        extend type PublicUserObject {\n          playlists: UserPlaylistsOutput!\n        }\n        extend type TrackObject {\n          audioFeatures: AudioFeaturesObject!\n        }"], "additionalResolvers": [{ "sourceName": "Spotify", "sourceTypeName": "Query", "sourceFieldName": "mePlaylists", "targetTypeName": "PrivateUserObject", "targetFieldName": "playlists" }, { "sourceName": "Spotify", "sourceTypeName": "Query", "sourceFieldName": "player", "targetTypeName": "PrivateUserObject", "targetFieldName": "player" }, { "sourceName": "Spotify", "sourceTypeName": "Query", "sourceFieldName": "meAlbums", "targetTypeName": "PrivateUserObject", "targetFieldName": "albums" }, { "sourceName": "Spotify", "sourceTypeName": "Query", "sourceFieldName": "meTracks", "targetTypeName": "PrivateUserObject", "targetFieldName": "tracks" }, { "sourceName": "Spotify", "sourceTypeName": "Query", "sourceFieldName": "meTopTracks", "targetTypeName": "PrivateUserObject", "targetFieldName": "topTracks" }, { "sourceName": "Spotify", "sourceTypeName": "Query", "sourceFieldName": "meTopArtists", "targetTypeName": "PrivateUserObject", "targetFieldName": "topArtists" }, { "sourceName": "Spotify", "sourceTypeName": "Query", "sourceFieldName": "albumTracks", "targetTypeName": "AlbumObject", "targetFieldName": "tracksFull", "requiredSelectionSet": "{ id }", "sourceArgs": { "id": "{root.id}" } }, { "sourceName": "Spotify", "sourceTypeName": "Query", "sourceFieldName": "artistAlbums", "targetTypeName": "ArtistObject", "targetFieldName": "albums", "requiredSelectionSet": "{ id }", "sourceArgs": { "id": "{root.id}" } }, { "sourceName": "Spotify", "sourceTypeName": "Query", "sourceFieldName": "artistTopTracks", "targetTypeName": "ArtistObject", "targetFieldName": "topTracks", "requiredSelectionSet": "{ id }", "sourceArgs": { "id": "{root.id}" } }, { "sourceName": "Spotify", "sourceTypeName": "Query", "sourceFieldName": "artistRelatedArtists", "targetTypeName": "ArtistObject", "targetFieldName": "relatedArtists", "requiredSelectionSet": "{ id }", "sourceArgs": { "id": "{root.id}" } }, { "sourceName": "Spotify", "sourceTypeName": "Query", "sourceFieldName": "playerRecentlyPlayed", "targetTypeName": "CurrentlyPlayingContextObject", "targetFieldName": "recentlyPlayed" }, { "sourceName": "Spotify", "sourceTypeName": "Query", "sourceFieldName": "playerDevices", "targetTypeName": "CurrentlyPlayingContextObject", "targetFieldName": "devices" }, { "sourceName": "Spotify", "sourceTypeName": "Query", "sourceFieldName": "meAlbumsContains", "targetTypeName": "PrivateUserObject", "targetFieldName": "albumsContains" }, { "sourceName": "Spotify", "sourceTypeName": "Query", "sourceFieldName": "meFollowingArtists", "targetTypeName": "PrivateUserObject", "targetFieldName": "followingArtists" }, { "sourceName": "Spotify", "sourceTypeName": "Query", "sourceFieldName": "meShows", "targetTypeName": "PrivateUserObject", "targetFieldName": "shows" }, { "sourceName": "Spotify", "sourceTypeName": "Query", "sourceFieldName": "meShowsContains", "targetTypeName": "PrivateUserObject", "targetFieldName": "showsContains" }, { "sourceName": "Spotify", "sourceTypeName": "Query", "sourceFieldName": "meTracksContains", "targetTypeName": "PrivateUserObject", "targetFieldName": "tracksContains" }, { "sourceName": "Spotify", "sourceTypeName": "Query", "sourceFieldName": "showEpisodes", "targetTypeName": "ShowObject", "targetFieldName": "episodesFull", "requiredSelectionSet": "{ id }", "sourceArgs": { "id": "{root.id}" } }, { "sourceName": "Spotify", "sourceTypeName": "Query", "sourceFieldName": "trackAudioFeatures", "targetTypeName": "TrackObject", "targetFieldName": "audioFeatures", "requiredSelectionSet": "{ id }", "sourceArgs": { "id": "{root.id}" } }, { "sourceName": "Spotify", "sourceTypeName": "Query", "sourceFieldName": "userPlaylists", "targetTypeName": "PublicUserObject", "targetFieldName": "playlists", "requiredSelectionSet": "{ id }", "sourceArgs": { "user_id": "{root.id}" } }], "transforms": [{ "filterSchema": { "filters": ["Query.!{mePlaylists, meAlbums, meTracks, meTopArtists}", "Query.!albumTracks", "Query.!artistAlbums", "Query.!{meAlbumsContains, meFollowingArtists, meShows, meShowsContains, meTracksContains}", "Query.!{playerCurrentlyPlaying, playerRecentlyPlayed, playerDevices}", "Query.!{playlistCoverImages, playlistTracks}", "Query.!showEpisodes", "Query.!trackAudioFeatures", "Query.!userPlaylists"] } }] };
export async function getMeshOptions() {
    const cache = new MeshCache({
        ...(rawConfig.cache || {}),
        store: rootStore.child('cache'),
    });
    const pubsub = new PubSub();
    const sourcesStore = rootStore.child('sources');
    const logger = new DefaultLogger('🕸️');
    const sources = [];
    const transforms = [];
    const spotifyTransforms = [];
    const spotifyHandler = new JsonSchemaHandler({
        name: rawConfig.sources[0].name,
        config: rawConfig.sources[0].handler["JsonSchema"],
        baseDir,
        cache,
        pubsub,
        store: sourcesStore.child(rawConfig.sources[0].name),
        logger: logger.child(rawConfig.sources[0].name),
        importFn
    });
    sources.push({
        name: 'Spotify',
        handler: spotifyHandler,
        transforms: spotifyTransforms
    });
    transforms.push(new FilterSchemaTransform({
        apiName: '',
        config: rawConfig.transforms[0]["filterSchema"],
        baseDir,
        cache,
        pubsub,
        importFn
    }));
    const additionalTypeDefs = [parse(/* GraphQL */ `extend type PrivateUserObject {
  playlists: BrowseFeaturedPlaylistsPlaylists!
  player: CurrentlyPlayingContextObject!
  albums: MeAlbumsOutput!
  tracks: MeTracksOutput!
  topTracks: MeTopTracksOutput!
  topArtists: MeTopArtistsOutput!
  followingArtists: MeFollowingArtistsOutput!
  shows: MeShowsOutput!
  albumsContains(ids: String!): [Boolean!]!
  showsContains(ids: String!): [Boolean!]!
  tracksContains(ids: String!): [Boolean!]!
}

extend type AlbumObject {
  tracksFull: AlbumTracksOutput!
}

extend type ArtistObject {
  albums: ArtistAlbumsOutput!
  topTracks(market: String!): ArtistTopTracksOutput!
  relatedArtists: ArtistRelatedArtistsOutput!
}

extend type CurrentlyPlayingContextObject {
  recentlyPlayed: PlayerRecentlyPlayedOutput!
  devices: DevicesObject!
}

extend type ShowObject {
  episodesFull: ShowEpisodesOutput!
}

extend type PublicUserObject {
  playlists: UserPlaylistsOutput!
}

extend type TrackObject {
  audioFeatures: AudioFeaturesObject!
}`),];
    const merger = new BareMerger({
        cache,
        pubsub,
        logger: logger.child('BareMerger'),
        store: rootStore.child('bareMerger')
    });
    const additionalResolversRawConfig = [];
    additionalResolversRawConfig.push(rawConfig.additionalResolvers[0]);
    additionalResolversRawConfig.push(rawConfig.additionalResolvers[1]);
    additionalResolversRawConfig.push(rawConfig.additionalResolvers[2]);
    additionalResolversRawConfig.push(rawConfig.additionalResolvers[3]);
    additionalResolversRawConfig.push(rawConfig.additionalResolvers[4]);
    additionalResolversRawConfig.push(rawConfig.additionalResolvers[5]);
    additionalResolversRawConfig.push(rawConfig.additionalResolvers[6]);
    additionalResolversRawConfig.push(rawConfig.additionalResolvers[7]);
    additionalResolversRawConfig.push(rawConfig.additionalResolvers[8]);
    additionalResolversRawConfig.push(rawConfig.additionalResolvers[9]);
    additionalResolversRawConfig.push(rawConfig.additionalResolvers[10]);
    additionalResolversRawConfig.push(rawConfig.additionalResolvers[11]);
    additionalResolversRawConfig.push(rawConfig.additionalResolvers[12]);
    additionalResolversRawConfig.push(rawConfig.additionalResolvers[13]);
    additionalResolversRawConfig.push(rawConfig.additionalResolvers[14]);
    additionalResolversRawConfig.push(rawConfig.additionalResolvers[15]);
    additionalResolversRawConfig.push(rawConfig.additionalResolvers[16]);
    additionalResolversRawConfig.push(rawConfig.additionalResolvers[17]);
    additionalResolversRawConfig.push(rawConfig.additionalResolvers[18]);
    additionalResolversRawConfig.push(rawConfig.additionalResolvers[19]);
    const additionalResolvers = await resolveAdditionalResolvers(baseDir, additionalResolversRawConfig, importFn, pubsub);
    const liveQueryInvalidations = rawConfig.liveQueryInvalidations;
    return {
        sources,
        transforms,
        additionalTypeDefs,
        additionalResolvers,
        cache,
        pubsub,
        merger,
        logger,
        liveQueryInvalidations,
    };
}
export const documentsInSDL = /*#__PURE__*/ [];
export async function getBuiltMesh() {
    const meshConfig = await getMeshOptions();
    return getMesh(meshConfig);
}
export async function getMeshSDK(sdkOptions) {
    const { schema } = await getBuiltMesh();
    return getSdk(schema, sdkOptions);
}
function handleExecutionResult(result, operationName) {
    if (result.errors) {
        const originalErrors = result.errors.map(error => error.originalError || error);
        throw new AggregateError(originalErrors, `Failed to execute ${operationName}: \n\t${originalErrors.join('\n\t')}`);
    }
    return result.data;
}
export function getSdk(schema, { globalContext, globalRoot, jitOptions = {} } = {}) {
    return {};
}
